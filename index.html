<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Platformer Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            flex-direction: column;
        }

        #gameCanvas {
            border: 4px solid #fff;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            background: #87CEEB;
        }

        .info {
            color: white;
            margin-top: 20px;
            text-align: center;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .controls {
            margin-top: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .controls p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="info">
        <div class="controls">
            <p><strong>Controls:</strong></p>
            <p>← → Arrow Keys: Move Left/Right</p>
            <p>Spacebar: Jump</p>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800;
        canvas.height = 600;

        // Game state
        const keys = {};

        // Physics constants
        const GRAVITY = 0.6;
        const FRICTION = 0.85;
        const MOVE_SPEED = 0.8;
        const JUMP_STRENGTH = -13;

        // Player object
        const player = {
            x: 100,
            y: 100,
            width: 20,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            isOnGround: false,
            
            // Initial spawn position
            spawnX: 100,
            spawnY: 100
        };

        // Platforms array
        const platforms = [
            { x: 0, y: 550, width: 300, height: 50, color: '#8B4513' },      // Bottom left platform
            { x: 350, y: 450, width: 200, height: 50, color: '#A0522D' },    // Middle low platform
            { x: 600, y: 550, width: 200, height: 50, color: '#8B4513' },    // Bottom right platform
            { x: 150, y: 350, width: 180, height: 50, color: '#A0522D' },    // Middle left platform
            { x: 450, y: 300, width: 150, height: 50, color: '#8B4513' },    // Middle right platform
            { x: 250, y: 200, width: 200, height: 50, color: '#A0522D' },    // Upper middle platform
            { x: 50, y: 100, width: 150, height: 50, color: '#8B4513' }      // Top left spawn platform
        ];

        // Keyboard event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            e.preventDefault();
        });

        // Draw stickman function (programmatic drawing)
        function drawStickman(x, y) {
            const headRadius = 8;
            const bodyLength = 25;
            const armLength = 18;
            const legLength = 20;
            
            // Center point (head position)
            const centerX = x + player.width / 2;
            const headY = y + headRadius + 5;
            const bodyStartY = headY + headRadius;
            const bodyEndY = bodyStartY + bodyLength;
            
            ctx.strokeStyle = '#000';
            ctx.fillStyle = '#FFE4C4';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            // Draw head (circle)
            ctx.beginPath();
            ctx.arc(centerX, headY, headRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#FFE4C4';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.stroke();
            
            // Draw body (line)
            ctx.beginPath();
            ctx.moveTo(centerX, bodyStartY);
            ctx.lineTo(centerX, bodyEndY);
            ctx.stroke();
            
            // Draw arms
            const armY = bodyStartY + 8;
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(centerX, armY);
            ctx.lineTo(centerX - armLength, armY + 10);
            ctx.stroke();
            
            // Right arm
            ctx.beginPath();
            ctx.moveTo(centerX, armY);
            ctx.lineTo(centerX + armLength, armY + 10);
            ctx.stroke();
            
            // Draw legs
            const legStartY = bodyEndY;
            
            // Left leg
            ctx.beginPath();
            ctx.moveTo(centerX, legStartY);
            ctx.lineTo(centerX - 8, legStartY + legLength);
            ctx.stroke();
            
            // Right leg
            ctx.beginPath();
            ctx.moveTo(centerX, legStartY);
            ctx.lineTo(centerX + 8, legStartY + legLength);
            ctx.stroke();
        }

        // AABB collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Handle player input
        function handleInput() {
            // Left arrow
            if (keys['ArrowLeft']) {
                player.velocityX -= MOVE_SPEED;
            }
            
            // Right arrow
            if (keys['ArrowRight']) {
                player.velocityX += MOVE_SPEED;
            }
            
            // Spacebar for jump (only if on ground)
            if (keys['Space'] && player.isOnGround) {
                player.velocityY = JUMP_STRENGTH;
                player.isOnGround = false;
            }
        }

        // Update physics
        function updatePhysics() {
            // Apply gravity
            player.velocityY += GRAVITY;
            
            // Apply friction
            player.velocityX *= FRICTION;
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Reset ground status
            player.isOnGround = false;
            
            // Check collision with platforms
            platforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    // Calculate overlap on each axis
                    const overlapX = Math.min(
                        player.x + player.width - platform.x,
                        platform.x + platform.width - player.x
                    );
                    const overlapY = Math.min(
                        player.y + player.height - platform.y,
                        platform.y + platform.height - player.y
                    );
                    
                    // Resolve collision based on smallest overlap
                    if (overlapX < overlapY) {
                        // Horizontal collision
                        if (player.x < platform.x) {
                            player.x = platform.x - player.width;
                        } else {
                            player.x = platform.x + platform.width;
                        }
                        player.velocityX = 0;
                    } else {
                        // Vertical collision
                        if (player.y < platform.y) {
                            // Landing on top of platform
                            player.y = platform.y - player.height;
                            player.velocityY = 0;
                            player.isOnGround = true;
                        } else {
                            // Hitting bottom of platform
                            player.y = platform.y + platform.height;
                            player.velocityY = 0;
                        }
                    }
                }
            });
            
            // Screen boundaries (left and right)
            if (player.x < 0) {
                player.x = 0;
                player.velocityX = 0;
            }
            if (player.x + player.width > canvas.width) {
                player.x = canvas.width - player.width;
                player.velocityX = 0;
            }
            
            // Reset if fallen off screen
            if (player.y > canvas.height) {
                player.x = player.spawnX;
                player.y = player.spawnY;
                player.velocityX = 0;
                player.velocityY = 0;
            }
        }

        // Draw platforms
        function drawPlatforms() {
            platforms.forEach(platform => {
                // Main platform
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // Platform border
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                
                // Platform texture (simple lines)
                ctx.strokeStyle = '#6B4423';
                ctx.lineWidth = 1;
                for (let i = 0; i < platform.width; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(platform.x + i, platform.y);
                    ctx.lineTo(platform.x + i, platform.y + platform.height);
                    ctx.stroke();
                }
            });
        }

        // Draw background
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Simple clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            
            // Cloud 1
            ctx.beginPath();
            ctx.arc(150, 80, 25, 0, Math.PI * 2);
            ctx.arc(180, 80, 30, 0, Math.PI * 2);
            ctx.arc(210, 80, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Cloud 2
            ctx.beginPath();
            ctx.arc(550, 120, 20, 0, Math.PI * 2);
            ctx.arc(575, 120, 25, 0, Math.PI * 2);
            ctx.arc(600, 120, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Cloud 3
            ctx.beginPath();
            ctx.arc(400, 60, 22, 0, Math.PI * 2);
            ctx.arc(430, 60, 28, 0, Math.PI * 2);
            ctx.arc(460, 60, 22, 0, Math.PI * 2);
            ctx.fill();
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            drawBackground();
            
            // Draw platforms
            drawPlatforms();
            
            // Handle input
            handleInput();
            
            // Update physics
            updatePhysics();
            
            // Draw player
            drawStickman(player.x, player.y);
            
            // Continue loop
            requestAnimationFrame(gameLoop);
        }

        // Start game
        gameLoop();
    </script>
</body>
</html>
